head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	2002.04.01.12.58.54;	author matt;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.10.19.32.12;	author matt;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.10.18.32.05;	author matt;	state Exp;
branches;
next	;


desc
@Functions for mail recipients
@


1.3
log
@Fixed debug to be more consistent and added group botch
@
text
@/*

 $Id: rcpt.c,v 1.2 2002/02/10 19:32:12 matt Exp matt $

 See COPYRIGHT for the license

*/
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <pwd.h>
#include "ssmtp.h"

extern char *root_user;
extern rcpt_t *rt;


/*
RCPT_parse() -- Break To|Cc|Bcc into individual addresses
*/
void RCPT_parse(char *str)
{
	bool_t in_quotes = False, got_addr = False;
	char *p, *q, *r;

#if 0
	(void)fprintf(stderr, "*** RCPT_parse(): str = [%s]\n", str);
#endif

	if((p = strdup(str)) == (char *)NULL) {
		die("RCPT_parse(): strdup() failed");
	}
	q = p;

	/* Replace <CR> and <TAB> */
	while(*q) {
		switch(*q) {
			case '\t':
			case '\n':
					*q = ' ';
		}
		q++;
	}
	q = p;
#if 0
	(void)fprintf(stderr, "*** RCPT_parse(): q = [%s]\n", q);
#endif

	r = q;
	while(*q) {
		if(*q == '"') {
			in_quotes = (in_quotes ? False : True);
		}

		/* End of string? */
		if(*(q + 1) == (char)NULL) {
			got_addr = True;
		}

		/* End of address? */
		if((*q == ',') && (in_quotes == False)) {
			got_addr = True;

			*q = (char)NULL;
		}

		if(got_addr) {
			while(*r && isspace(*r)) r++;

			RCPT_save(ADDR_parse(r));
			r = (q + 1);
#if 0
			(void)fprintf(stderr,
				"*** RCPT_parse(): r = [%s]\n", r);
#endif
			got_addr = False;
		}
		q++;
	}
	free(p);
}

/*
RCPT_save() -- Store entry into RCPT list
*/
void RCPT_save(char *str)
{
	char *p;

	/* Horrible botch for group stuff */
	p = str;
	while(*p) p++;
	if(*--p == ';') {
		return;
	}

#if 0
	(void)fprintf(stderr, "*** RCPT_save(): str = [%s]\n", str);
#endif

	if((rt->string = strdup(str)) == (char *)NULL) {
		die("RCPT_save() -- strdup() failed");
	}

	rt->next = (rcpt_t *)malloc(sizeof(rcpt_t));
	if(rt->next == (rcpt_t *)NULL) {
		die("RCPT_save() -- malloc() failed");
	}
	rt = rt->next;

	rt->next = (rcpt_t *)NULL;
}

/*
RCPT_remap() -- alias systems-level users to the person who
	reads their mail.  This is variously the owner of a workstation,
	the sysadmin of a group of stations and the postmaster otherwise.
	We don't just mail stuff off to root on the mailhub (:-))
*/
char *RCPT_remap(char *str)
{
	struct passwd *pw;

	if(strchr(str, '@@') ||
		((pw = getpwnam(str)) == NULL) || (pw->pw_uid > MAXSYSUID)) {
		/* It's not a local systems-level user */
		return(append_domain(str));
	}
	else {
		return(append_domain(root_user));
	}
}
@


1.2
log
@Added cast on NULL check
@
text
@d3 1
a3 1
 $Id$
d24 1
a24 1
	char *p, *q, *r, *s;
d27 1
a27 1
	(void)fprintf(stderr, "RCPT_parse(): str = [%s]\n", str);
d46 1
a46 1
	(void)fprintf(stderr, "RCPT_parse(): q = [%s]\n", q);
d70 1
a70 2
			s = ADDR_parse(r);
			RCPT_save(s);
d73 2
a74 1
			(void)fprintf(stderr, "RCPT_parse(): r = [%s]\n", r);
a79 1

d88 9
@


1.1
log
@RCPT processing functions for sSMTP
@
text
@d1 7
d30 1
a30 1
	if((p = strdup(str)) == NULL) {
d93 1
a93 1
	if((rt->string = strdup(str)) == NULL) {
@
