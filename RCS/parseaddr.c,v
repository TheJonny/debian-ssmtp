head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	2001.07.20.18.51.20;	author matt;	state Exp;
branches;
next	;


desc
@Parse out email address from RFC822 header
@


1.1
log
@Initial revision
@
text
@/*
 * parseaddr.c	Read a valid RFC822 address with all the comments
 *		etc in it, and return _just_ the email address.
 *
 * Version:	@@(#)parseaddr.c  1.00  02-Apr-1999  miquels@@cistron.nl
 *
 */

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <ctype.h>

struct token {
	struct token *next;
	char word[1];
};

#define SKIPSPACE(p) do { while(*p && isspace(*p)) p++; } while(0)

/*
 *	Skip everything between quotes.
 */
void quotes(char **ptr)
{
	char		*p = *ptr;

	p++;
	while (*p && *p != '"') {
		if (*p == '\\' && p[1])
			p++;
		p++;
	}
	*ptr = p;
}

/*
 *	Return the next token. A token can be "<>()," or any "word".
 */
static struct token *gettoken(char **ptr)
{
	struct token	*tok;
	char		*p = *ptr;
	char		*begin;
	int		l, quit = 0;

	SKIPSPACE(p);
	begin = p;

	while (!quit) {
		switch (*p) {
			case 0:
			case ' ':
			case '\t':
			case '\n':
				quit = 1;
				break;
			case '(':
			case ')':
			case '<':
			case '>':
			case ',':
				if (p == begin) p++;
				quit = 1;
				break;
			case '\\':
				if (p[1]) p++;
				break;
			case '"':
				quotes(&p);
				break;
		}
		if (!quit) p++;
	}

	l = p - begin;
	if (l == 0) return NULL;
	if ((tok = malloc(sizeof(struct token) + l)) == NULL)
		return NULL;
	tok->next = NULL;
	strncpy(tok->word, begin, l);
	tok->word[l] = 0;

	SKIPSPACE(p);
	*ptr = p;

	return tok;
}

/*
 *	Get email address from rfc822 address.
 */
int parseaddr(char *addr, char *buf, int bufsz)
{
	char		*p;
	struct token	*t, *tok, *last;
	struct token	*brace = NULL;
	int		comment = 0;

	tok = last = NULL;

	/*
	 *	Read address, remove comments right away.
	 */
	p = addr;
	while ((t = gettoken(&p)) != NULL && t->word[0] != ',') {
		if (t->word[0] == '(' || t->word[0] == ')' || comment) {
			free(t);
			if (t->word[0] == '(')
				comment++;
			if (t->word[0] == ')')
				comment--;
			continue;
		}
		if (t->word[0] == '<')
			brace = t;
		if (tok)
			last->next = t;
		else
			tok = t;
		last = t;
	}

	/*
	 *	Put extracted address into "buf"
	 */
	buf[0] = 0;
	t = brace ? brace->next : tok;
	for (; t && t->word[0] != ',' && t->word[0] != '>'; t = t->next) {
		if (strlen(t->word) >= bufsz)
			return -1;
		bufsz -= strlen(t->word);
		strcat(buf, t->word);
	}

	/*
	 *	Free list of tokens.
	 */
	for (t = tok; t; t = last) {
		last = t->next;
		free(t);
	}

	return 0;
}
@
