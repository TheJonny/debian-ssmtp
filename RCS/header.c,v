head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	2002.04.01.12.57.58;	author matt;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.29.14.50.10;	author matt;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.10.21.05.02;	author matt;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.10.19.31.27;	author matt;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.10.18.32.19;	author matt;	state Exp;
branches;
next	;


desc
@Header processing functions
@


1.5
log
@Additional debug
@
text
@/*

 $Id: header.c,v 1.4 2002/03/29 14:50:10 matt Exp matt $

 See COPYRIGHT for the license

*/
#include <stdlib.h>
#include <string.h>
#include "ssmtp.h"

extern bool_t FROM_override;
extern bool_t SEEN_from;
extern bool_t SEEN_date;
extern bool_t minus_t;
extern headers_t *ht;
extern char *full_from;


/*
HEADER_record() -- note which headers we've seen
*/
void HEADER_record(char *str)
{
	char *p;

#if 0
	(void)fprintf(stderr, "*** HEADER_record(): str = [%s]\n", str);
#endif

	if(strncasecmp(str, "From:", 5) == 0) {
		if((full_from = strdup((str + 6))) == (char *)NULL) {
			die("HEADER_record():");
		}
		SEEN_from = True;
	}
#ifdef HASTO_OPTION
	else if(strncasecmp(str, "To:" ,3) == 0) {
		SEEN_to = True;
	}
#endif
	else if(strncasecmp(str, "Date:", 5) == 0) {
		SEEN_date = True;
	}

	if(minus_t) {
		/* Need to figure out recipients from the e-mail */
		if(strncasecmp(str, "To:", 3) == 0) {
			p = (str + 4);
			RCPT_parse(p);
		}
		else if(strncasecmp(str, "Bcc:", 4) == 0) {
			p = (str + 5);
			RCPT_parse(p);
		}
		else if(strncasecmp(str, "CC:", 3) == 0) {
			p = (str + 4);
			RCPT_parse(p);
		}
	}
}

/*
HEADER_parse() -- Break headers into seperate entries
*/
void HEADER_parse(FILE *stream)
{
	size_t size = BUF_SZ, len = 0;
	char *p = (char *)NULL, *q;
	bool_t in_headers = True;
	char c, l = (char)NULL;

	while(in_headers && ((c = (char)fgetc(stream)) != EOF)) {
		if((p == (char *)NULL) || (len >= size)) {
			size += BUF_SZ;

			p = (char *)realloc(p, (size * sizeof(char)));
			if(p == (char *)NULL) {
				die("HEADER_parse() -- realloc() failed");
			}
			q = (p + len);
		}
		len++;

		if(l == '\n') {
			switch(c) {
				case ' ':
				case '\t':
						break;

				case '\n':
						in_headers = False;

				default:
						*q = (char)NULL;
						if((q = strrchr(p, '\n'))) {
							*q = (char)NULL;
						}
						HEADER_save(p);

						q = p;
						len = 0;
			}
		}
		*q++ = c;

		l = c;
	}
	(void)free(p);
}

/*
HEADER_save() -- Store entry into header list
*/
void HEADER_save(char *str)
{
	char buf[(BUF_SZ + 1)];
	char *p;

	if((p = strdup(str)) == (char *)NULL) {
		die("HEADER_save() -- strdup() failed");
	}

#ifdef REWRITE_DOMAIN
	if(FROM_override == False) {
		if(strncpy(buf, str, BUF_SZ) == (char *)NULL) {
			die("HEADER_save() -- strncpy() failed");
		}
		FROM_rewrite(buf, BUF_SZ);

		if((p = strdup(buf)) == (char *)NULL) {
			die("HEADER_save() -- strdup() failed");
		}
	}
#endif
	ht->string = p;

	ht->next = (headers_t *)malloc(sizeof(headers_t));
	if(ht->next == (headers_t *)NULL) {
		die("HEADER_save() -- malloc() failed");
	}
	ht = ht->next;

	ht->next = (headers_t *)NULL;
}
@


1.4
log
@Bug fixes and updated naming convention
@
text
@d3 1
a3 1
 $Id: header.c,v 1.3 2002/02/10 21:05:02 matt Exp matt $
a46 4
#if 0
		(void)fprintf(stderr,
			"*** HEADER_record(): str = [%s]\n", str);
#endif
a49 4
#if 0
			(void)fprintf(stderr,
				"*** HEADER_record(): p = [%s]\n", p);
#endif
@


1.3
log
@Added FROM_rewrite code
@
text
@d3 1
a3 1
 $Id: header.c,v 1.2 2002/02/10 19:31:27 matt Exp matt $
d17 1
d32 3
d48 2
a49 1
	(void)fprintf(stderr, "*** HEADER_record(): str = [%s]\n", str);
d77 1
a77 1
	char *buf = (char *)NULL, *p;
d82 1
a82 1
		if((buf == (char *)NULL) || (len >= size)) {
d85 2
a86 2
			buf = (char *)realloc(buf, (size * sizeof(char)));
			if(buf == (char *)NULL) {
d89 1
a89 1
			p = (buf + len);
d103 3
a105 3
						*p = (char)NULL;
						if((p = strrchr(buf, '\n'))) {
							*p = (char)NULL;
d107 1
a107 1
						HEADER_save(buf);
d109 1
a109 1
						p = buf;
d113 1
a113 1
		*p++ = c;
d117 1
a117 1
	(void)free(buf);
d125 2
a126 1
	char * p;
d134 8
a141 1
		FROM_rewrite(p, strlen(p));
a143 1

@


1.2
log
@Added cast on NULL check
@
text
@d3 1
a3 1
 $Id$
d12 1
d120 3
a122 1
	if((ht->string = strdup(str)) == (char *)NULL) {
d125 8
@


1.1
log
@HEADER processing functions for sSMTP
@
text
@d1 7
d119 1
a119 1
	if((ht->string = strdup(str)) == NULL) {
@
